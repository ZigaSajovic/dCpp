\documentclass{article}

\usepackage[slovene]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\II}{\mathbb{I}}
\newcommand{\JJ}{\mathbb{J}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\T}{\mathcal{T}}
\newcommand{\VV}{\mathcal{V}}
\newcommand{\MM}{\mathcal{M}}
\newcommand{\NN}{\mathcal{N}}
\newcommand{\e}{\mathbf{e}}
\newcommand{\x}{\mathbf{x}}
\newcommand{\m}{\mathbf{m}}
\newcommand{\uu}{\mathbf{u}}
\newcommand{\vv}{\mathbf{v}}
\newcommand{\F}{\mathcal{F}}
% operator odvoda
\newcommand{\D}{\partial}
%operator 1 + \D
\newcommand{\Dplus}{\mathcal{D}}
% operator 1+ \D + \D^2 + ...
\newcommand{\sumd}{\tau}
\newcommand{\Op}{\partial^{\bigoplus}}
\newcommand{\op}[1]{\partial^{#1\bigoplus}}
\DeclareMathOperator{\interior}{int}
\newtheorem{definicija}{Definicija}[section]
\newtheorem{trditev}{Trditev}[section]
\newtheorem{izrek}{Izrek}[section]
\newtheorem{opomba}{Opomba}[section]
\newtheorem{konstrukcija}{Konstrukcija}[section]
\title{Analitični stroji}
\author{Žiga Sajovic, Martin Vuk}
\begin{document}
\maketitle
\begin{abstract}
  Dandanes matematične funkcije pogosto računamo z računalniki. Če je funkcija
  odvedljiva, nas včasih zanima tudi, koliko je njen odvod. Večina bralcev verjetno
  pozna simbolično odvajanje izrazov ali numerično odvajanje s končnimi
  diferencami. V tem prispevku bova predstavila še en način, kako lahko določimo
  odvode funkcije, ki jo računamo z računalniškim programom. \emph{Avtomatsko
    odvajanje} je skupno ime za različne postopke, s katerimi program, ki računa
  vrednosti odvedljive funkcije, preoblikujemo v program, ki izračuna odvod. 
  Večina algoritmov za avtomatsko odvajanje znajo to narediti brez dodatnega
  človekovega posega (odtod ime avtomatski). Za razliko
  od numeričnega odvajanja ne trpijo za izgubo natančnosti. Prednost pred
  simboličnim odvajanjem, pa je v tem, da jih lahko uporabimo tudi v primeru, ko
  ne poznamo eksplicitne formule, ampak vrednosti računamo s programom.

  Avtomatsko odvajanje je uporabno povsod, kjer potrebujemo 
  odvode funkcij, ki jih računamo s kompleksnimi algoritmi. Tipični primeri so
  optimizacija parametrov pri strojnem učenju, računanje odvoda preslikave, ki nima
  eksplicitne formulacije (npr. Poincarejeva preslikava za dinamične sisteme,
  lastne vrednosti matrik, ...).
\end{abstract}
\section{Uvod}
Za začetek si oglejmo preprost primer, na katerem ilustriramo osnovno idejo.
Recimo, da računamo vrednosti funkcije $y=\sqrt{x}$ z babilonskim oziroma Haronovim obrazcem.
Pri tem postopku, najprej izberemo začetni približek za
kvadratni koren $y_0=y_z$. Nato pa z rekurzivno formulo
\begin{equation*}
  y_n=\frac{1}{2}\left( y_{n-1}+\frac{x}{y_{n-1}} \right)
\end{equation*}
računamo člene zaporedja $y_n$. Zaporedje $y_n$ konvergira zelo hitro k
vrednosti $\sqrt{x}$, zato so vrednosti $y_n$ že po nekaj korakih zelo blizu
iskani vrednosti $\sqrt{x}$. Opisani postopek lahko prevedemo v računalniški
program. Na primer v programskem jeziku Python, bi program izgledal takole 

\begin{verbatim}
y = x/2
while abs(y*y-x) > 5e-11:
  y = (y+x/y)/2
\end{verbatim}

Pri tem smo za začetni približek izbrali $x/2$, lahko pa bi izbrali tudi kaj
drugega. Vrednost pa nas zanima na 10 decimalk natančno. 
Za funkcijo $f(x)$ želimo izračunati tudi njen odvod $f'(x)$. V našem
primeru lahko odvod preprosto izrazimo s funkcijo $f'(x)=\frac{1}{2\sqrt{x}}$,
ampak zamislimo si, da funkcije $f$ sploh ne poznamo, ampak poznamo le računalniški program za
njen izračun. Še vedno pa bi radi izračunali vrednosti odvoda $f'(x)$. Uporabimo
lahko numerične približke za odvod, vendar pri tem izgubimo natančnost. 

Osnovna ideja avtomatskega odvajanja je v tem, da odvajamo program. Računalniški program ni nič drugega kot zaporedje osnovnih
računskih operacij in premetavanja vrednosti po pomnilniku. V našem primeru
uporabljamo dve spremenljivki \texttt{x} in \texttt{y}, zato si lahko vsako vrstico
programa, ki spreminja vrednosti \texttt{x} ali \texttt{y} predstavljamo kot
funkcijo $\phi_i:\RR^2\to\RR^2$. Označimo z $(x_k,y_k)$ vrednosti spremenljivk
\texttt{x} in \texttt{y}, po izvedbi $k$-te vrstice programa in pred izvedbo
$k+1$-ve vrstice. Vsaka vrstica programa določa preslikavo
\begin{eqnarray*}
  \phi_k&:&\RR^2\to \RR^2\\
  \phi_k&:&(x_{k-1},y_{k-1})\mapsto (x_k,y_k).
\end{eqnarray*}
Celoten program predstavlja preslikavo $F:(x_0,y_0)\mapsto (x_n,y_n)$, ki jo
lahko predstavimo kot kompozitum preslikav $\phi_k$, defniranih z vsako vrstico programa:
\begin{equation*}
  F(x_0,y_0) = \phi_n\circ\phi_{n-1}\circ \ldots \phi_1(x_0,y_0) = \phi_n(\phi_{n-1}(\ldots \phi_1(x_0,y_0)\ldots))
\end{equation*}

Odvod preslikave $F$ lahko po verižnem pravilu izrazimo kot produkt Jacobijevih matrik
$\D\phi_i$ preslikav $\phi_i$. Ker nas zanima le odvod $y$ po $x$, matriko $\D F$
pomnožimo z leve in desne z vektorjem $(0,1)$ 
\begin{equation}
\label{eq:kompozitum}
  \frac{dy}{dx} =
  \begin{bmatrix}
    0& 1
  \end{bmatrix}
\cdot \D\phi_n(x_{n-1},y_{n-1})\cdot \D\phi_{n-1}(x_{n-2},y_{n-2})\ldots \D\phi_1(x_0,y_0)\cdot
  \begin{bmatrix}
    0\\
    1
  \end{bmatrix} 
\end{equation}
Program za računanje odvoda lahko povsem sledi originalnemu programu, le da si
mora na vsakem koraku zapomniti vmesne vrednosti odvoda. Na vsakem
koraku programa, si mora program za odvod zapomniti vektor
\begin{equation*}
\begin{bmatrix}dx_{k}\\dy_{k}\end{bmatrix} = \D\phi_{k}(x_{k-1},y_{k-1})\ldots \D\phi_1(x_0,y_0)\cdot \begin{bmatrix} 0\\ 1\end{bmatrix} 
\end{equation*}
Vrednost $(dx_k,dy_k)$ lahko definiramo rekurzivno
\begin{equation}
  \label{eq:rek_odvod}
\begin{bmatrix}dx_{k}\\dy_{k}\end{bmatrix} = \D\phi_{k}(x_{k-1},y_{k-1})\cdot \begin{bmatrix} dx_{k-1}\\ dy_{k-1}\end{bmatrix} 
\end{equation}
V našem primeru je 
\begin{equation*}
  \phi_1(x,y)=(x,x/2)\text{ in } \phi_n(x,y)=\left(x,\frac{1}{2}\left( y+\frac{x}{y} \right)\right)
\end{equation*}
Vrednost spremenljivke $x$ se ne spreminja tekom programa, zato je dovolj, da
spremljamo le vrednosti odvoda po $y$
\begin{equation*}
  \frac{d}{dx}\phi_0(x,y(x))_2=1/2\text{ in }\frac{d}{dx}\phi_k(x,y(x))_2=\frac{1}{2}\left( \frac{dy}{dx}+\left(\frac{1}{y}-\frac{x}{y^2}\frac{dy}{dx}\right) \right)
\end{equation*}
 
Naslednji program poleg vrednosti funkcije (spremenljivka \texttt{y}) računa
tudi njen odvod (spremenljivka \texttt{dy})
\begin{verbatim}
y = x/2
dy = 0.5
while abs(y*y-x) > eps:
  y = (y+x/y)/2
  dy = (dy + (1/y - x/(y*y)*dy)/2
\end{verbatim}

\section{Avtomatsko odvajanje}
Na uvodnem primeru smo videli, da si lahko računalniški program predstavljamo
kot vektorsko funkcijo več spremenljivk. Vektorska funkcija, ki predstavlja
program, je podana kot kompozitum preslikav, ki ustrezajo posameznim vrsticam
programa. Program za odvod smo napisali tako, da smo vsaki vrstici
programa dodali vrstico, ki je izračunala odvod. Ta postopek lahko namesto nas
opravi računalnik (od tod ime avtomatski odvod). V nadaljevanju bomo opisali dva
načina, kako je to izvedeno v obstoječih knjižnicah. 

Oglejmo si matematični model, s katerim lahko utemeljimo postopke avtomatičnega
odvajanja. V našem modelu bomo zajeli le spremenljivke predstavljene s števili s
plavajočo vejico,  s katerimi v računalniku predstavljamo realna števila. 
Ostale spremenljivke kot so števci v zankah, celoštevilske vrednosti, logične
vrednosti in podobne ne bodo vključene v našem modelu, ampak jih upoštevamo
zgolj kot parametre, ki sicer vplivajo na potek programa, vendar njihovega
vpliva ne moremo infinitezimalno obravnavati. Če predpostavimo, da so vse
spremenjivke, ki nas zanimajo tipa \texttt{float} (ali \texttt{double)}), si lahko stanje spomina
predstavljamo kot $n$-razsežni realni vektor\footnote[1]{omejitev, da je
  spremenljivka tipa \texttt{float}, smo vpeljali zgolj zaradi enostavnosti.
  Odvajamo lahko po poljubnem tipu, ki to dopušča. Če bi npr. definirali
  poseben tip, ki bi predstavljal funkcijo, bi na isti način lahko računali
  funkcijski odvod, kot ga poznamo v variacijskem računu.}. Vsaka spremenljivka(lokacija v
spominu) predstavlja eno komponento tega vektorja. Množico vseh možnih stanj
spomina, s katerim razpolaga program, lahko modeliramo z $n$-razsežnim
vektorskim prostorom $V\simeq\RR^n$. Vektorski prostor $V$ bomo imenovali
\emph{virtualni pomnilnik programa}. Računalniški program, ki
ima na voljo $n$-mest v virtualnem pomnilniku, si lahko predstavljamo kot preslikavo
\begin{equation}
  \label{eq:program_kot_preslikava}
  P: V\to V,
\end{equation}
kjer je $V$ vektorski prostor dimenzije $n$. Množica vseh takih preslikav
opremljena z operacijo kompozituma je \emph{monoid}.
\begin{definicija}
  Naj bo $V$ Banachov vektroski prostor. Preslikava $P:V\to V$ je odvedljiva v
  točki $x\in V$, če obstaja
  linearen omejen operator $TP_x:V\to V$, za katerega je
  \begin{equation}
    \label{eq:frechet}
    \lim_{h\to 0}\frac{\|P(x+h)-P(x)-TP_x(h)\|}{\|h\|} = 0.
  \end{equation}
  Preslikavo $TP_x$ imenujemo \emph{Fréchetov odvod}. Preslikavo 
  \begin{equation}
    \label{eq:linearizacija}
    h\mapsto P(x)+TP_x(h)
  \end{equation}
 imenujemo \emph{linearizacija} preslikave $P$ v točki $x$.
\end{definicija}
Za preslikave $\RR^n\to \RR^m$ lahko Fréchetov odvod
izrazimo kot množenje vektorja $h$ z Jacobijevo matriko $\D P$ parcialnih odvodov
komponent preslikave $P$
\begin{equation*}
  TP_x(h) = \D P(x)\cdot h.
\end{equation*}
\subsection{Polinomi in simetrična algebra}
V prejšnjem razdelku smo definirali odvod kot \emph{linearizacijo} preslikave v dani
točki. Pojem bi radi posplošili na aproksimacije s polinomi višjih stopenj.  
 Naj bo $V$ vektorski prostor nad obsegom $F$. Linearne preslikave $V\to V$
 lahko predstavimo s tenzorji 2. reda iz prostora $V\otimes V^*$. Če je
 $\vv\otimes f\in V\otimes V^*$, je preslikava
 \begin{equation}
   \label{eq:lin_tenzor}
   \x \mapsto f(\x)\cdot \vv
 \end{equation}
linearna preslikava (v koordinatah je matrika te preslikave produkt stopca $\vv$
in vrstice $f$). Vsako linearno preslikavo lahko zapišemo kot linearno
kombinacijo preslikav te vrste.

Podobno lahko definiramo monomske preslikave $V\to V$. Označimo z $V^{\otimes k}
= V\otimes V\ldots \otimes V$ tenzorski produkt $k$-kopij prostora $V$. Število
$k$ imenujemo \emph{red} tenzorja. Tenzorji reda $0$  so skalarji $V^{\otimes
  0}=F$, medtem ko so tenzorji reda 1 vektorji. Poljuben tenzor reda $k$ iz
prostora $(V*)^{\otimes k}$, definira multilinearno funkcijo $V^k\to F$. Na
tenzorjih oblike $f_1\otimes f_2\otimes \ldots\otimes f_k$ je definirana s
formulo
\begin{equation}
  \label{eq:multilinear_f}
  (\vv_1,\vv_2,\ldots,v_k) = f_k(\vv_1)f_{k-1}(\vv_2)\cdots f_1(\vv_k)
\end{equation}
ki se po linearnosti razširi na ves $(V^*)^{\otimes k}$.
\begin{definicija}[Tenzorska in simetrična algebra]
  Naj bo $V$ vektorski prostor nad obsegom $F$. \emph{Tenzorska algebra} $T(V)$ je direktna vsota
  \begin{equation}
    \label{eq:tenzorska_algebra}
    T(V)=\bigoplus_{k=0}^\infty V^{\otimes k}=F\oplus V\oplus (V\otimes V)\oplus (V\otimes V\otimes V)\oplus\ldots
  \end{equation}
opremljena z operacijo tenzorskega produkta, ki je določena s kanoničnim
izomorfizmom $V^{\otimes k}\otimes V^{\otimes l}\to V^{\otimes (k+1)}$. 
\emph{Simetrična algebra} $S(V)$ je kvocientna algebra $T(V)/\mathcal{I}$, kjer
je $\mathcal{I}$ ideal generiran z elementi oblike
\begin{equation}
  \label{eq:simetricna_algebra}
  v\otimes u -u\otimes v.
\end{equation}
\end{definicija}
Tenzorska algebra je množica linearnih kombinacij tenzorjev različnega ranga.
Splošen element $T(V)$ bomo imenovali
\emph{multitenzor}. Podobno bomo splošen element simetrične algebre imenovali
\emph{simetrični multitenzor}.
Če so vektorji  $\{\e_i;\quad i=1,2,\ldots n\}$ baza prostora $V$, lahko poljuben
element $T(V)$ enolično zapišemo kot
\begin{equation}
  \label{eq:multitenzor}
  \m = \sum_{\alpha\in \JJ}m_\alpha e_{\alpha_1}\otimes e_{\alpha_2}\otimes\ldots e_{\alpha_{k_\alpha}},
\end{equation}
kjer so koeficienti $m_\alpha\in F$ in je $\JJ$ množica vseh multiindeksov z
vrednostmi v $\{1,2,\ldots,n\}$. Prav tako lahko vsak element simetrične algebre
enolično zapišemo s podobno vsoto, le da gre vsota le po množici urejenih multinideksov.\footnote{Urejen multiindeks $\alpha$ dolžine $k$ je $k$-terica
števil $(\alpha_1,\alpha_2, \ldots \alpha_k)$, kjer so vsi
$\alpha_i\in{1,2,\ldots n}$ in velja $\alpha_i\le\alpha_j$, če je $i<j$.}.
 

\subsection{Višji odvodi}
Naj bo $P:V\to U$ odvedljiva v vsaki točki $\x\in V$. Odvod $T_\x P$ preslikave $P$ je v
vsaki točki linearna preslikava, ki jo lahko predstavimo s tenzorjem iz
$U\otimes V^*$. Odvod definira preslikavo 
\begin{eqnarray}
  \label{eq:odvod_preslikava}
  \D P&:& V\to U\otimes V^*\\
  \D P&:& \x \mapsto T_\x P.
\end{eqnarray}
Če gledamo na odvod kot na preslikavo $\D P:V\to U\otimes V^*$, lahko zopet govorimo
o njeni odvedljivosti. Odvod preslikave $\D P$ imenujemo \emph{drugi odvod}
preslikave $P$ in ga označimo z $\D^2P$. Drugi odvod je v vsaki točki linearna
preslikava $V\to U\otimes V^*$, kar pomeni, da jo lahko predstavimo s tenzorjem
iz prostora $(U\otimes V^*)\otimes V^*$. Na drugi odvod lahko zopet gledamo kot
na preslikavo 
$$\D^2 P:V\to U\otimes V^*\otimes V^*.$$ 
Podobno lahko definiramo višje odvode

\begin{definicija}[Višji odvodi]
  Naj bo $P:V\to U$ preslikava med dvema vektorskima prostoroma $V$ in $U$. Odvod reda $k$ je preslikava $\D^kP:V\to U\otimes(V^*)^{\otimes k}$, ki
  vsaki točki $\x\in V$ priredi odvod $T_\x(\D^{k-1}P)$ odvoda reda $k-1$, kot
  preslikave $\D^{k-1}P: V\to U\otimes (V^*)^{\otimes k-1}$:
  \begin{eqnarray}\label{eq:partial}
    \label{eq:visji_odvod}
    \D^kP&:&V\to U\otimes (V^*)^{\otimes k}\\
    \D^kP&:&\x\mapsto T_\x\left( \D^{k-1}P \right)
  \end{eqnarray}
\end{definicija} 
\begin{opomba}
   V zgornji definiciji smo predpostavili, da so preslikava $P$ in njeni odvodi v
  vseh točkah $v$ odvedljivi. Seveda se lahko dogodi, da v nekaterih točkah
  odvod reda $k$ ne obstaja. V tem primeru bi lahko domeno $V$ ustrezno zožali.
  Zaradi jasnosti, se bomo delali, da so vse preslikave, s katerimi imamo
  opravka povsod neskončno krat odvedljive.
\end{opomba}

Iz definicije vidimo, da višji odvodi niso nič posebnega, le večkrat uporabimo
odvajanje. Opazimo, da je prostor v katerega višji odvodi slikajo $V$
vedno drugačen. Temu se lahko elegantno izognemo, če definiramo operator
odvajanja na univerzalnem virtualnem prostoru $U\otimes T(V^*)$. Vsako preslikavo $P:V\to U\otimes (V^*)^{\otimes k}$ lahko gledamo kot na
preslikavo $V\to U\otimes T(V)$, če jo na drugem faktorju komponiramo z naravno
vložitvijo $(V^*)^{\otimes k}\hookrightarrow T(V^*)$. Tako lahko preslikavo
$P:V\to U$ in vse njene odvode razumemo kot preslikave 
$$\D^k P:V\to U\otimes T(V^*).$$ 
\begin{definicija}\label{def:partial}
  Odvod
  $\D$ je operator na prostoru odvedljivih preslikav $V\to U\times T(V^*)$, ki
  vsaki preslikavi priredi njen odvod
  \begin{equation}
    \label{eq:odvod_splosen}
    \D : P \mapsto (\D P:\x\mapsto T_\x P)
  \end{equation}
\end{definicija}
Višji odvodi so torej preprosto potence operatorja $\D$.

Označimo z $T_k(V)=V^{\otimes 0}\oplus V \oplus V^{\otimes 2} \oplus \cdots
\oplus V^{\otimes k}$ in z $S_k(V)$ ustrezen simetričen del. Prostor $U\otimes
S_k(V^*)$ je izomorfen  prostoru vseh polinomskih preslikav $V\to U$ stopnje $k$
ali manj. Operator $\D$ slika $U\otimes T_k(V^*)$ v $U\otimes T_{k+1}(V^*)$.


\subsection{Odvedljivi stroji}

V nadaljevanju bomo definirali, kako si predstavljamo odvedljiv programski jezik
oziroma računski stroj. Odvedljiv stroj si bomo predstavljali kot računski
stroj, ki izvaja zaporedne enostavne operacije, ki so odvedljive, na virtualnem
pomnilniku $\VV\simeq\RR^n$. 
Zanimali nas bodo stroji, ki manipulirajo z virtualnim
pomnilnikom $\VV$. Osnovne operacije na stroju so preslikave 
$\epsilon_i:\VV\to \VV$.
\begin{definicija}[računski stroj]
  Par $(\VV,\E)$, kjer je $\VV$ končnodimenzionalen vektorski prostor in $\E$
  končna množica preslikav $\VV\to \VV$ imenujemo \emph{računski stroj}.
  Prostoru $\VV$ pravimo \emph{virtualni pomnilnik}, preslikavam $\epsilon_i$ pa
  \emph{elementarne operacije}.
\end{definicija}

\begin{definicija}[Odvedljiv program z domeno]
  Naj bosta $V<\VV$ in $U<\VV$ podprostora virtualnega pomnilnika.
  \emph{Odvedljiv program z domeno $V$} je vsaka odvedljiva preslikava
  \begin{equation}
    \label{eq:odvedljiv_program}
    P:V\to U,
  \end{equation}
 ki se v vsaki točki $\vv\in V$ na odprti okolici izraža kot kompozitum neke afine vložitve $i_V:V\hookrightarrow
 \VV$, zaporedja elementarnih operacij $\epsilon_\vv^{i}$  in projekcije $pr_U:\VV\to U$
 \begin{equation}
   \label{eq:zapis}
   P = pr_U\circ \epsilon_\vv^{k_\vv}\circ \cdots \circ \epsilon_\vv^1\circ i_V.
 \end{equation}
\end{definicija}
\begin{opomba}
  Domena programa $V$ določa, po katerih spremenljivkah bomo odvajali. Tekom
  programa se to ne bo spreminljalo, zato moramo v virtualnem pomnilniku
  rezervirati prostor le za $U\otimes S_k(V^*)$, kjer je $U$ prostor odvisnih
  spremenljivk, ki so v danem trenutku alocirane v virtualnem pomnilniku. Faktor 
$S_k(V^*)$ se ne spreminja, ne glede na to kakšna je dimenzija domene in
ko-domene za vmesne operacije. Na ta način zmanjšamo potrebo po spominu na minimum.
\end{opomba}
Program $P:V\to U$ je \emph{brez stranskih učinkov}, če je zožitev preslikave 
na $U^\perp$ 
$$ pr_{U^\perp}\circ \epsilon_k\circ \cdots \circ \epsilon_k\circ i_{U^\perp}=Id_{U^\perp}$$  
identiteta. To pomeni, da program ne spreminja pomnilnika, razen na lokacijah, 
kamor se zapiše izhod programa. 
 
\subsubsection{Komponiranje programov z domeno} 
 
Program z domeno je matematični model za programerske funkcije. Domena programa 
prostor $V$ je prostor argumentov funkcije, medtem ko je prostor $U$ prostor 
vrednosti, ki ji funkcija vrne. Preslikava $i_V$, pove katere spremenljivke smo 
postavili kot argumente funkciji, medtem ko $pr_U$ pove, kam smo shranili 
vrednosti, ki jih funkcija vrne. Zaporedje ukazov $\epsilon_i$ pa pove, kako 
funkcija vrednosti dejansko izračuna. 
Zanima nas, kako lahko funkcije med sabo komponiramo. Naj bosta $P:V\to U$ in 
$Q:U\to W$ programa z domeno $V$ oziroma $U$. Njuna kompozicija bo imela smisel 
le, če je $i_U\circ pr_U$ identiteta na $\VV$. V nasprotnem primeru bi to 
pomenilo, da se s klicem funkcije $Q$ ``pokvari'' del pomnilnika, ki nima nobene 
zveze z argumenti funkcije $Q$ 

Prostor $\T_V$ opisuje vse možne programe z domeno $V$, na našem
stroju, množica generatorjev $\E$ pa elementarne operacije, ki jih stroj lahko
izvaja. Ker je $\T_V=\langle \E \rangle$, lahko vsak program $P$ zapišemo kot
kompozitum elementarnih operacij $\epsilon_i$:
\[
P = \epsilon_k\circ\epsilon_{k-1}\ldots\epsilon_0.
\]  

Če želimo tekom programa sproti računati tudi odvode, moramo hraniti vmesne
vrednosti odvodov. Zato moramo pomnilnik (vektorski prostor $V$) razširiti, da
bo vseboval tudi odvode. Odvod je linearna preslikava $V\to V$, prostor
vseh linearnih preslikav $\mathcal{L}(V)$ je izomorfen tenzorskemu produktu
$V^*\otimes V$. Tako za izvedbo programa, ki računa odvode, potrebujemo virtualni
pomnilnik izomorfen prostoru $V\oplus (V^*\otimes V)$. Poleg vsake spremenljivke $x_j$, ki
jo uporabimo v programu, si moramo zapomniti še vrednosti odvodov po vseh
ostalih spremenljivkah $\frac{\partial x_j}{\partial x_i}$.   

Za višje odvode rekurzivno definiramo zaporedje vektorskih prostorov $V_n$, ki
predstavljajo virtualni pomnilnik
\begin{eqnarray}\label{eq:V_n}
  \label{eq:prapor}
  V_0 &=& V\\
  V_{n+1}&=&V\oplus (V^*\otimes V_n),
\end{eqnarray} 
ki ga potrebuje program za izračun vrednosti $n$-tih odvodov. Izbira $V_n\simeq
V\oplus (V^*\otimes V) \oplus (V^*\otimes V^*\otimes V) \ldots \oplus
(V^*)^{\otimes n}\otimes V$ odraža dejstvo, da za izračun vrednosti $n$-tega odvoda v neki točki $x\in V$
potrebujemo vrednosti funkcije in vseh nižjih odvodov.
\begin{definicija}
  Direktno limito zaporedja vektorskih prostorov $V_n$ imenujemo
  \emph{univerzalni virtualni prostor} in jo označimo z $V_\infty$.
\end{definicija}
\begin{izrek}
  Univerzalni virtualni prostor je izomorfen tenzorskemu produktu virtualnega
  prostora $V$ in tenzorske algebre $T(V^*)$ duala virtualnega prostora $V^*$:
  \begin{equation}
\label{eq:tenzor_algebra}
    V_\infty\simeq V\otimes T(V^*) = V \otimes\left(\bigoplus_{k=0}^\infty (V^*)^{\otimes k} \right)
\end{equation}

\end{izrek}

Elementi $V_\infty$ predstavljajo neskončne potenčne vrste kot preslikave 
$V\to V$. Prostor $(V^*)^{\times n}\otimes V$ je izomorfen prostoru
multilinearnih preslikav $V^{\times n}\to V$. Če poljubno
multilinearno preslikavo komponiramo z vložitvijo $V\to V^{\times n}$ na
diagonalo, dobimo preslikavo $V\to V$, ki se v koordinatah izraža kot linearna
kombinacija monomov stopnje $n$.

\begin{izrek}
 Dimenzija prostora $V_n$ je $\frac{k-k^{n+2}}{1-k}$, kjer je k dimenzija $V$.
 \end{izrek}

\begin{proof}
	$$dim(V_n)=dim(V)\sum\limits_{i=0}^{n}dim((V^*)^{\otimes i})$$
	$$dim(V^*)=dim(V)\land dim\Big((V)^{\otimes n}\Big)=div(V)^n$$
	$$\implies$$
	$$dim(V_n)=dim(V)\sum\limits_{i=0}^{n}dim(V)^{i}$$
	$$dim(V_n)=dim(V)\frac{1-dim(V)^{n+1}}{1-dim(V)}$$
\end{proof}

Spominska kompleksnost modela je eksponentna. Gre poudarit, da v praksi redko projeciramo na celoten $V$, pogosteje nas zanima manjša podmnožica komponent.
\subsection{Polinomske aproksimacije in Taylorjeva vrsta}
Naj bo $f_1\otimes f_2\otimes \ldots \otimes f_k\in (V^*)^{\otimes k}$
tenzor. Tenzorju lahko priredimo multilinearno funkcijo $f:V^k\to F$ 
\begin{eqnarray}
  \label{eq:multilinear}
f&:&(v_1,v_2,\ldots,v_k) \mapsto \prod_{i=1}^k f_i(v_{k-i+1}) 
\end{eqnarray}
Preslikava $f$ je \emph{multilinearna}. Zgornjo definicijo lahko po linearnosti
razširimo na vse tenzorje v $(V^*)^{\otimes k}$. Tako dobimo, da je prostor
$\mathrm{Mul}(V,k)$ multilinearnih preslikav ranga $k$ izomorfen $k$-ti stopnici
$(V^*)^{\otimes k}$ tenzorske algebre $T(V^*)$. 
Za vsako multilinearno preslikavo $f:V^k\to F$, ki je podana s tenzorjem
$f_1\otimes f_2\otimes\ldots \otimes f_k$ lahko definiramo polinom $p:V\to
F$ stopnje $k$\footnote{polinom, ki ga tako dobimo je linearna kombinacija monomov stopnje $k$}, tako da v $f$ vstavimo $(v,v,\ldots, v)$:
\begin{equation}
  \label{eq:polinom}
  p(v) = f(v,v,\ldots, v) = \prod_{i=1}^kf_i(v).
\end{equation}
Podobno kot pri multilinearnih preslikavah, lahko definicijo (\ref{eq:polinom})
po linearnosti razširimo na vse tenzorje iz $(V^*)^{\otimes k}$ pa tudi na
poljubne multitenzorje, se pravi na celotno tenzorsko algebro $T(V)$. Razlika je v
tem, da preslikava, ki tenzorjem iz $(V^*)^{\otimes k}$ priredi polinom, ni
izomorfizem, saj je invarijantna na permutacije faktorjev v tenzorskem
produktu. Zato preslikava podano z (\ref{eq:polinom}) definira izomorfizem
simetrične algebre $S(V^*)$ in prostora polinomov.
\begin{izrek}
  Prostor polinomov na vektorskem prostoru $V$ je izomorfen simetrični algebri
  $S(V^*)$. Izomorfizem je podan z razširitvijo formule (\ref{eq:polinom}) po
  linearnosti na poljubne multitenzorje.
\end{izrek}
Označimo z $\{\e_1,\e_2,\ldots,\e_n\}$ bazo prostora $V$ in z $\{x_1,x_2,\ldots,
x_n\}$ dualno bazo $V^*$. Funkcionali $x_i$ niso nič drugega kot koordinatne
funkcije v razvoju po bazi $\{\e_i\}$. Poljuben multitenzor $f\in T(V^*)$ lahko
zapišemo kot 
$$f = \sum_{\alpha \in \JJ}f_\alpha x_{\alpha_1}\otimes
x_{\alpha_2}\otimes\ldots \otimes x_{\alpha_k}$$
Če je multitenzor $f$ končen (le končno neničelnih $f_\alpha$),  mu lahko
priredimo polinom 
$$p(x_1\e_1+x_2\e_2+\ldots +x_n\e_n)=\sum_{\alpha \in \JJ}f_\alpha x_{\alpha_1}\cdot
x_{\alpha_2}\cdot\ldots  x_{\alpha_{k_\alpha}}.$$
 
Posvetimo se sedaj preslikavam med dvema vektorskima prostoroma $P:V\to U$.
Pokazali bomo, da končni multitenzorji prostora $U\otimes S(V^*)$ določajo
polinomske preslikave $V\to U$. Linearne preslikave $V\to U$ lahko predstavimo s
tenzorji iz $U\otimes V^*$. Naj bo 
$$f=\sum_{|\alpha|\le m}\uu_\alpha\otimes x_{\alpha_1}\otimes x_{\alpha_2}\otimes
\ldots \otimes x_{\alpha_{k_\alpha}}$$ multitenzor reda $m$. Preslikava, ki jo
multitenzor $f$ definira s predpisom 
$$f(v) = \sum_{|\alpha|\le m}\left( x_{\alpha_1}(v)\cdot x_{\alpha_2}(v)\cdot
\ldots \cdot x_{\alpha_{k_\alpha}}(v) \right)\uu_\alpha$$
je po komponentah polinomska in vsako preslikavo $V\to U$, ki se po komponetah izraža s
polinomi stopnje največ $m$, lahko predstavimo z multitenzorjem reda $m$.
  

Naj bosta $U, V < \RR^n$ podprostora istega vektorskega prostora. Množenje v
univerzalnem virtualnem prostoru definiramo tako, da se ujema s kompozitumom
polinomskih preslikav. Naj bosta $u\otimes f_1\otimes\ldots \otimes f_k$ in
$v\otimes g_1\otimes \ldots g_l$ tenzorja. Potem je produkt
\begin{equation}
  \label{eq:produkt}
 \left( u\otimes f_1\otimes\ldots \otimes f_k \right)\cdot \left(v\otimes g_1\otimes \ldots g_l\right) = f_1(v)\cdots f_k(v) u\otimes g_1^{\otimes k}\otimes \ldots \otimes g_l^{\otimes k}
\end{equation}

\begin{definicija}[Aproksimacija s Taylorjevim polinomom]
Naj $P$ program (se pravi funkcija na virtualnem pomnilniku $P:V\to V$). Odvod
reda $n$ oziroma aproksimacija stopnje $n$ je polinomska preslikava
$T^{(n)}_xP:V\to V$ stopnje $n$ za katero velja
\begin{equation}
  \label{eq:aprox}
  \lim_{h\to 0}\frac{\|P(x+h)-T^{(n)}_xP(h)\|}{\|h\|^n}=0
\end{equation}
\end{definicija}

\subsection{Algebra funkcijskih prostorov}

Razdelajmo pojme, ki nam bodo kasneje omogočili algebraične manipulacije in analizo vzpostavljenih objektov.

Za enostavnost izražanja definirajmo funkcijske prostore
 
 \begin{equation}\label{eq:F^n}
 	\F^n:V\to V\otimes(V^*)^{n\otimes}
 \end{equation}
 in
 
 \begin{equation}\label{eq:F_n}
 	\F_n:V\to V_n
 \end{equation}
 
Naj bo $\D^k$ $\eqref{eq:odvod_splosen}$ definiran kot

\begin{equation}\label{eq:dd}
	\partial^k=\sum_{\forall_{i,\alpha}}\frac{\partial^k}{\partial
	    x_{\alpha_1}\ldots \partial x_{\alpha_k}}\e_i\otimes
	  dx_{\alpha_1}\otimes\ldots \otimes dx_{\alpha_k} , x_i\in V_{j\in\JJ}
\end{equation}

Tako je $\D^k$ preslikava med funkcijskimi prostori $\eqref{eq:F^n}$
 
 \begin{equation}\label{eq:toFn+k}
 \D^k:\F^n\to\F^{n+k}
 \end{equation}
 
 \begin{izrek}
 	Operator $\D^k$ je rekuziven homomorfizem.
 	$$\D^k(P_1\circ P_2)=\D^{k-1}(\D P_1\circ\D P_2)$$
 \end{izrek}
 
 V telesu algoritmov paradigm, kot je $\textit{deli in vladaj}$ je rekurziven homomorfizem ekvivalenten klasičnem homomorfizmu. To dejstvo sprida izkoriščamo pri učinkovitih implementacijah.
 
 \begin{izrek}\label{izr:linearnaNeodvisnost}
  Množica $\{\partial^k\}$ predstavlja linearno neodvisne vektorje nad poljem $K$.
 \end{izrek}
 
 \begin{proof} 
 $$\forall_i(c_i\in K)$$
	  $$c_0+c_1\D+c_2\D^2+....+c_n\D^n=0$$
	$$\D(c_0+c_1\D+c_2\D^2+....+c_n\D^n)=0$$
	$$\implies$$
	$$(\D)(c_0+c_1\D+c_2\D^2+....+c_n\D^n)(\F)=(c_0+c_1\D+c_2\D^2+....+c_n\D^n)(\F)$$
	$$\implies$$
	$$(\D)(\F^n)=\F^n$$
	$$\F^{n+1}=\F^n\iff\forall_i(c_i=0)$$
	
 \end{proof}
 Definiramo lahko geometrijsko vrsto
 
 \begin{equation}\label{eq:DD}
  	\sumd_n = 1+\D +\D^2 +\ldots + \D^n 
  \end{equation}
  
  
  \begin{equation}
  	\sumd_n=\sum\limits_{n=0}^{n}\sum_{\forall_{i,\alpha}}\frac{\partial^n}{\partial
  		    x_{\alpha_1}\ldots \partial x_{\alpha_k}}\e_i\otimes
  		  dx_{\alpha_1}\otimes\ldots \otimes dx_{\alpha_k} , x_i\in V_{j\in\JJ}
  \end{equation}
  
  Po Izreku $\ref{izr:linearnaNeodvisnost}$ je operator $\sumd_n$ edinstven.

\begin{definicija}
Naj bo $\T_n$ podprostor, ki ga množica $\{\partial^k\}$ napenja nad $\mathbb{Z}_2$.
 \end{definicija}
 
 \begin{opomba}
        Podprostor $\T_n$ naseljujejo programi $n$-tega reda. Napetost nad $\mathbb{Z}_2$ zoža splošen prostor $\F_n$ na oglišča hiper-kocke. Odvode $(m\le n)$-tega reda izluščimo skozi projekcije na ustrezna oglišča.
        \end{opomba}
 
 \begin{izrek}\label{izr:T_n}
 	$\sumd_n$ je operator na prostoru $\T$, ki vsaki preslikavi priredi
 	\begin{equation}
 	\sumd_n:\T\to\T_n
 	\end{equation}
 \end{izrek}
 
 \begin{proof} 
 	$$(c_0+c_1\D+c_2\D^2+....+c_n\D^n)(\T)\in\F_n$$
 	$$c_0+c_1\D+c_2\D^2+....+c_n\D^n=\sumd_n\iff \forall_i(c_i=1)$$
 	$$\implies$$
 	$$(\sumd_n)(\T)=\T_n$$
  \end{proof}

Po Izreku $\ref{izr:T_n}$ lahko računanje odvodov preslkave $P:V\to U$, predstavimo z eno samo
preslikavo $\T\to\T_n$.

Operator $\sumd_k$ vsaki preslikavi $P: V\to U$ priredi preslikavo $\sumd_k:V\to
U\otimes T(V^*)$, sestavljeno iz preslikave same in vseh odvodov reda $k$ in
manj. Slika $\sumd_kP(\x)$ je multitenzor reda $k$, ki je direktna vsota
vrednosti preslikave $P$ in vseh odvodov reda $k$ in manj, vseh evaluiranih v
točki $\x$:
\begin{equation}
  \label{eq:multi_odvod}
  \sumd_kP(\x) = P(\x)+\D_\x P + \D^2_\x P + \ldots + \D^k_\x P.
\end{equation}
\begin{izrek}
  Operator $\sumd_k$ je definiran rekurzivno s formulo
  \begin{equation}
    \label{eq:potenca(1+d)}
    \sumd_{k+1}=1+\D\sumd_{k}
  \end{equation}
in začetnim pogojem $\tau_0=1$.
\end{izrek}
Očitno velja preprosta rekurzivna zveza med $\sumd_k$ in $\sumd_{k+1}$
\begin{equation}
   \label{eq:rekurzija}
   \sumd_{k+1} = 1 + \D +\D^2+\ldots \D^{k+1} = 1+\D(1+\D+\ldots +\D^{k}) = 1+\D\sumd_k.
\end{equation} 


 \subsection{Razvoj v vrsto}
  
  Analizo motiviramo s primerom. Predpostavimo časovno kompleksen algoritem $A$, za katerega iščemo približek. Z opisano mehaniko lahko program lineariziramo.
  Izberemo $v\in PV$ in preslikamo v $v'\in P'V_1$ (kar je potrebno storiti le enkrat). Potem lahko program $PV$ približamo z linearno aproksimacijo $v+(v'-v) (V)$, ki je linearne kompleksnost $\mathcal{O}(k)$, kjer je $k$ dimenzija $V$.
  %enačba pomeni, da vektorju odštšteješ "realni" del
  Slika linearizacije služi kot dober približek slike prvotnega programa.
  
  
  Za nadaljevanje je prikladno vnesti nekaj notacije. Naj multitenzor $\VV^{ik}_{\JJ_k}\in V_n (\ref{eq:V_n})$ predstavlja element virtualnega prostora. $\JJ_k$ je nabor indexov, $\lvert\JJ_k\rvert$ je enak redu odvoda. Index $k=\lvert\JJ_k\rvert$, zato ga v zapisu izpuščamo. 
  
  \begin{equation}\label{eq:tenV}
  	\VV^{ik}_{\JJ_k}= \bigoplus\limits_{0\le k\le n} \VV^{ik}_{\JJ_k}
  \end{equation}
  
  Tako je $\eqref{eq:tenV}$ preslikava iz tenzorske algebre $T(V)$ v $V$
  
  \begin{equation}\label{eq:vto}
  	\VV^{ik}_{\JJ_k}:\bigoplus\limits_{0\le k\le n}V^{\JJ_k}_{k}\to V^i
  \end{equation}
  
  V tej notaciji linearizacija postane
  
  \begin{equation}\label{eq:linear}
 	\VV^i+\VV^i_j(v^j-v_0^j)
  \end{equation}
  
  Induktivno bi želeli program razvit v vrsto. Po Izreku $\ref{izr:linearnaNeodvisnost}$  obstaja prostor, ki ga množica $\{\D^k\}$ napenja nad $\RR$. Zato je izraz
  
  
 \begin{equation}
 	e^{h\D}=\sum\limits_{n=0}^{\infty}\frac{(h\D)^n}{n!}
 \end{equation}
 
 dobro definiran.
 
 \begin{equation}\label{eq:e^d}
 	e^{h\D}=\sum\limits_{n=0}^{\infty}\frac{h^n}{n!}\sum_{\forall_{i,\alpha}}\frac{\partial^n}{\partial
 		    x_{\alpha_1}\ldots \partial x_{\alpha_n}}\e_i\otimes
 		  dx_{\alpha_1}\otimes\ldots \otimes dx_{\alpha_n}
 \end{equation}
 
 Tako je $e^{h\D}$ preslikava med funkcijskimi prostori $\eqref{eq:F_n}$
 
 \begin{equation}
 	e^{h\D}:\F\to\F_n
 \end{equation}
 
 Zato velja
  
  \begin{equation}\label{eq:specProg}
  	(e^{h\D})(\F):V^i\to V_n^i
  \end{equation}
 
 Po $\eqref{eq:vto}$ je $V_n$ izomorfen komutativno asociativni unitalni algebri $S(V^{i*})$, kar korespondira polinomom z nedoločenkami v $V^i$. Po $\eqref{eq:specProg}$ velja
 
 \begin{equation}
 	(e^{h\D})(V): \F\to S(V^*)
 \end{equation}
 Izraz predstavlja preslikavo programa v polinom.
 
\begin{izrek}
	Za program $P\in\T$ in $v^{\JJ_k}_{k}\in T(V)$ se razvoj v vrsto izraža kot zožitev\\
	\begin{equation}\label{eq:tenzorVrsta}
	P(V^i+hv) = \Big((e^{h\D})(P)(V^i)\Big)v^{\JJ_k}_{k}
	\end{equation}
\end{izrek}
 
 \begin{proof}
 Za vsak $n$ velja $\lim\limits_{\lVert h\rVert\to 0}(\frac{d}{dh})^n\text{(LHS)}=\lim\limits_{\lVert h\rVert\to 0}(\frac{d}{dh})^n\text{(RHS)}$\\
 $\implies$
 
 $$\lim\limits_{\lVert h\rVert\to 0}(\frac{d}{dh})^n(P(V+hv))=\D^n P(V)(v^{\otimes n})$$
 $\impliedby$
 $$\lim\limits_{\lVert h\rVert\to 0}(\frac{d}{dh})^n\Big((e^{h\D})(P)(V^i)\Big)(v^{\JJ_k}_{k})=\lim\limits_{\lVert h\rVert\to 0}\Big((\D^n e^{h\D})(P)(V^i)\Big)(v^{\JJ_k}_{k})$$
 $$\land$$
 $$\lim\limits_{\lVert h\rVert\to 0}\D^ne^{h\D}=\lim\limits_{\lVert h\rVert\to 0}\sum\limits_{i=0}^{\infty}\frac{h^i\D^{i+n}}{i!}=\D^n$$
 $$\implies$$
 $$\Big(\D^n(P)(V^i)\Big)(v^{\otimes n})$$
 \end{proof}
  
 Slika zožitve je element prvotnega virtualnega prostora $V^i$. Neodvisnost $(\ref{eq:tenzorVrsta})$ od koordinatnega sistema, se v programiranju prevede na neodvisnost v izvajanju. Tako je izraz $(\ref{eq:tenzorVrsta})$ invarianten stopnji izvajanja programa.   
 
 Razvoj v odrezano vrsto reda $N$ dobimo skozi projekcijo $e^{h\D}$ na $\{\D^N \}$.
  
\subsection{Analitični stroji}
   
Naj bo $\mathrm{P}\subset\T$ preslikava $V_\JJ\to V_\II$. Slika predstavlja
mnogoterost $\mathcal{M}\subset V_\II$ (dejansko je unija zlepkov kot definrano
v \ref{eq:zlepek}).

  
  Skupaj z definicijami prejšnjih sestavkov, lahko konstruiramo analitičen abstrakten stroj, ki z opisano mehaniko razširja množico Turing-izračunljivih strojev.
  
  \begin{definicija}
   $M=\langle\T, V_\infty, \D\rangle$ je analitičen računski stroj.
   
    \begin{itemize}
    \item
    $V_\infty$ služi kot množica stanj, domena ter "neskončen trak"
    \item
    $\T$ je monoid preslikav $V\to V$
    \item
    $\D$ je diferencialni operator
    \end{itemize}
  \end{definicija}
 
 Karkoli operira pod temi specifikacijami, je analitičen Turingov stroj.
 Ob konstrukciji $M$, je potrebna le enkratna aplikacija $\Dplus: \T\to\T_1$. Naj $\T_1: V\to V_1$ označuje programski jezik prvega reda in $M_1=\langle\T_1, V_\infty, \D\rangle$ stroj, ki ga implementira. Vsak program $P_1\in\T_1$, generiran v $M_1$, v vsaki točki izvajanja nosi informacijo spremembe prvega reda.
 
 Definirajmo stroj $n$-tega reda
 \begin{equation}\label{eq:Mprime}
	 \Dplus^n M=\langle\Dplus^n\T, V_\infty, \D\rangle
 \end{equation}
 oziroma v vzpostavljeni, ekvivalentni notaciji
  \begin{equation}\label{eq:M'}
 	 M_n=\langle\T_n, V_\infty, \D\rangle
  \end{equation}
  Tako je operator $\Dplus^n$ preslikava analitičnega stroja $M$ v stroj $M_n$. Tukaj se razume, da aktira le s prvim elementom trojca.
  
  \begin{izrek}\label{izr:dM}
	$M_n=\langle\T_n, V_\infty, \D\rangle$ je analitičen računski stroj.
  \end{izrek}

\begin{proof}
	Iz $\eqref{eq:DD}$ sledi $\Dplus^{n+1}=1+\D\Dplus^n$ in po definiciji velja	
	$$M_{n+1}=\langle\Dplus^{n+1}\T,V_\infty,\D\rangle$$
		$$\implies$$
	$$M_{n+1}=\langle\T+\D\T_n,V_\infty,\D\rangle$$	
\end{proof}


  Vsak analitičen stroj intrinzično vsebuje zmožnost razširitve reda. To pomeni, da nam stroj $n+1$ reda ni potrebno konstruirati skozi aplikacijo $\Dplus^n$ na $M$, temveč lahko po Izreku $\ref{izr:dM}$ red $M_{n}$ inkrementiramo.
  
  Vsi programi konstruirani v $M_n$, skozi zaporedje akcij $\T_n$ nad $V$, v vsaki točki izvajanja vsebujejo informacijo spremembe prvih $n$ redov. Tak program označimo s $P_n$.
  
  \begin{equation}
  P_{n} = \epsilon^{n'}_k\circ\epsilon^{n'}_{k-1}\ldots\epsilon^{n'}_0
  \end{equation}
  
kjer velja $\E^n\in\T_n\subset\F_n$.
 
% Z ustrezno izbiro projekcije $\mathcal{P}_\II$ programa, kot $\mathcal{M}\subset V$, omogočimo preučevanje njegovega učinka na $V$. Projeciramo lahko na enotske vektorje, ki predstavljajo konceptualni vhod programa in proučujemo spremembe akcije nad $V$. S tem merimo odzivnost programa na vhodne podatke. Diagram izvajanja programa lahko predstavimo z usmerjenim grafom;- potem lahko projeciramo na, in odvajamo po kateremkoli izmed njegvih oglišč.
 
 \subsection{Optimizacija prostorske zahtevnosti}
 Ponavadi nas ne zanima odvod po vseh spremenljvkah, ki jih imamo v programu.
 Označimo z $\{\e_i,\quad i=1,2,\ldots n\}$ standardne bazne vektorje v $\RR^n$ in z
 $\II\subset\{1,2,\ldots n\}$ množico indeksov. Indeksi v $\II$ ustrezajo
 posameznim spremenljivkam (indeksi določajo lokacijo spremenljivke v spominu). Naj bo $V_\II$ vektorski
 podprostor napet na vektorje $\{e_i;\quad i\in\II\}$. Označimo z 
 $\mathcal{P}_\II$ projekcijo na $V_i$, z $\mathcal{I}_\II$ pa vložitev $V_\II$ v
 $\RR^n$. Vložitev $\mathcal{I}_\II$ ni mišljena kot linearna preslikava, ampak
 dopuščamo, da so vrednosti spremenljivk, ki niso v $\II$, poljubne. Recimo, da nas zanima nabor spremenljivk z indeksi $\II$, ki jih
 program $P$ izračuna na podlagi nabora spremenljivk z indeksi $\mathbb{J}$.
 Preslikavo med $V_\JJ\to V_\II$, ki jo določa program $P$, lahko zapišemo kot
 \begin{equation}
   \label{eq:zozitev}
   P^{\JJ}_{\II}=\mathcal{P}_\II\circ P\circ \mathcal{I}_\JJ 
 \end{equation}
 Odvod preslikave $ P^{\JJ}_{\II}$ je enak produktu
 \begin{equation*}
   P^{\JJ}_{\II}=P_\II\cdot DP\cdot I_\JJ,   
 \end{equation*}
 kjer sta $P_\II$ in  $I_\JJ$ matriki, ki ustrezata projekciji na $V_\II$ oziroma
 vložitvi $V_\JJ$ v $\RR^n$.
 
 
 
 \subsection{Kontrolne strukture}
 
 Do sedaj smo se omejili na operacije, ki spreminjajo vsebino spomina. Poleg
 prireditvenih ukazov, poznamo tudi kontrolne ukaze (npr. stavki \texttt{if},
 \texttt{for}, \texttt{while}, ...). Kontrolni stavki ne vplivajo neposredno na
 vrednost spremenljivk, ampak spreminjajo potek programa. Seveda bo to vplivalo
 tudi na odvod. Ampak za določen nabor vhodnih spremenljivk, bo potek programa
 vedno enak. Zato si lahko kontrolne strukture predstavljamo kot definicijo
 zlepka. Vzemimo naprimer preprost program v programskem jeziku Python
 \begin{verbatim}
 def abs(x):
   if x<0:
    return -x
   else
    return x
 \end{verbatim}
 Funkcija \texttt{abs(x)} je program, ki izračuna zlepek
 \begin{equation}
   \label{eq:zlepek}
   |x| =
   \begin{cases}
     -x;\quad x<0\\
     x;\quad x\ge 0
   \end{cases}
 \end{equation}
 Vsaka kontrolna struktura razdeli prostor parametrov na različna območja,
 znotraj katerih je potek programa enak. Celoten program torej razdeli prostor
 vseh možnih parametrov na končno množico območij $\{\Omega_i;\quad i=1,\ldots
 k\}$, kjer je potek programa enak. Program lahko torej v splošnem definiramo kot
 zlepek. Za $\vec{x}\in\RR^n$ je
 \begin{equation}
   \label{eq:zlrprk_splosno}
   P(\vec{x}) =
   \begin{cases}
     P_{n_11}\circ P_{(n_1-1)1}\circ\ldots P_{11}(\vec{x});&\quad \vec{x}\in\Omega_1\\
     P_{n_22}\circ P_{(n_2-1)2}\circ\ldots P_{12}(\vec{x});&\quad \vec{x}\in\Omega_2\\
     \vdots&\quad\vdots\\
     P_{n_kk}\circ P_{(n_k-1)k}\circ\ldots P_{1k}(\vec{x});&\quad \vec{x}\in\Omega_k\\
   \end{cases}
 \end{equation}
 Diferencial $\sumd_nP$ programa $P$ je seveda tudi odvisen od začetnih parametrov
 $\vec{x}$ in ga tudi lahko podamo kot zlepek a le v notranjosti deinicijskih območij $\Omega_i$
 \begin{equation}
   \label{eq:Dzlrprk_splosno}
   \sumd_nP_{\vec{x}} =
   \begin{cases}
     \sumd_nP_{n_11}\cdot \sumd_nP_{(n_1-1)1}\cdot\ldots \sumd_nP_{11};&\quad \vec{x}\in\interior(\Omega_1)\\
     \sumd_nP_{n_22}\cdot \sumd_nP_{(n_2-1)2}\cdot\ldots \sumd_nP_{12}(\vec{x});&\quad \vec{x}\in\interior(\Omega_2)\\
     \vdots&\quad\vdots\\
     \sumd_nP_{n_kk}\cdot \sumd_nP_{(n_k-1)k}\cdot\ldots \sumd_nP_{1k}(\vec{x});&\quad \vec{x}\in\interior(\Omega_k)\\
   \end{cases}
 \end{equation}
 Problem je seveda na robu območju $\partial\Omega_i$, kjer program $P$ ni nujno odvedljiv.

Vejitve programa na območja izvajamo skozi pogojne stavke $(if/else)$. Število območij $\Omega_i$ je enako moči množice $\{\Omega_i\}$. Vsak pogojni stavek, povzroči binarno vejitev v izvajanju programa

\begin{izrek}
Moč množice $\{\Omega_i\}$ je enaka $\lvert\{\Omega_i \}\rvert=2^k$, kjer je $k$ število pogojnih stavkov, ki jih vsebuje program.
\end{izrek}
\subsection{Direktno odvajanje}
\subsection{Obratno odvajanje}
\end{document}
