\documentclass{article}

\usepackage[slovene]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\II}{\mathbb{I}}
\newcommand{\JJ}{\mathbb{J}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\T}{\mathcal{T}}
\newtheorem{izrek}{Izrek}[section]
\title{Avtomatsko odvajanje}
\author{Žiga Sajovic, Martin Vuk}
\begin{document}
\maketitle
\begin{abstract}
  Dandanes matematične funkcije pogosto računamo z računalniki. Če je funkcija
  odvedljiva, nas včasih zanima tudi, koliko je njen odvod. Večina bralcev verjetno
  pozna simbolično odvajanje izrazov ali numerično odvajanje s končnimi
  diferencami. V tem prispevku bova predstavila še en način, kako lahko določimo
  odvode funkcije, ki jo računamo z računalniškim programom. \emph{Avtomatsko
    odvajanje} je skupno ime za različne postopke, s katerimi program, ki računa
  vrednosti odvedljive funkcije, preoblikujemo v program, ki izračuna odvod. 
  Večina algoritmov za avtomatsko odvajanje znajo to narediti brez dodatnega
  človekovega posega (odtod ime avtomatski). Za razliko
  od numeričnega odvajanja ne trpijo za izgubo natančnosti. Prednost pred
  simboličnim odvajanjem, pa je v tem, da jih lahko uporabimo tudi v primeru, ko
  ne poznamo eksplicitne formule, ampak vrednosti računamo s programom.

  Avtomatsko odvajanje je uporabno povsod, kjer potrebujemo 
  odvode funkcij, ki jih računamo s kompleksnimi algoritmi. Tipični primeri so
  optimizacija parametrov pri strojnem učenju, računanje odvoda preslikave, ki nima
  eksplicitne formulacije (npr. Poincarejeva preslikava za dinamične sisteme,
  lastne vrednosti matrik, ...).
\end{abstract}
\section{Uvod}
Za začetek si oglejmo preprost primer, na katerem ilustriramo osnovno idejo.
Recimo, da računamo vrednosti funkcije $y=\sqrt{x}$ z babilonskim oziroma Haronovim obrazcem.
Pri tem postopku, najprej izberemo začetni približek za
kvadratni koren $y_0=y_z$. Nato pa z rekurzivno formulo
\begin{equation*}
  y_n=\frac{1}{2}\left( y_{n-1}+\frac{x}{y_{n-1}} \right)
\end{equation*}
računamo člene zaporedja $y_n$. Zaporedje $y_n$ konvergira zelo hitro k
vrednosti $\sqrt{x}$, zato so vrednosti $y_n$ že po nekaj korakih zelo blizu
iskani vrednosti $\sqrt{x}$. Opisani postopek lahko prevedemo v računalniški
program. Na primer v programskem jeziku Python, bi program izgledal takole 

\begin{verbatim}
y = x/2
while abs(y*y-x) > 5e-11:
  y = (y+x/y)/2
\end{verbatim}

Pri tem smo za začetni približek izbrali $x/2$, lahko pa bi izbrali tudi kaj
drugega. Vrednost pa nas zanima na 10 decimalk natančno. 
Za funkcijo $f(x)$ želimo izračunati tudi njen odvod $f'(x)$. V našem
primeru lahko odvod preprosto izrazimo s funkcijo $f'(x)=\frac{1}{2\sqrt{x}}$,
ampak zamislimo si, da funkcije $f$ sploh ne poznamo, ampak poznamo le računalniški program za
njen izračun. Še vedno pa bi radi izračunali vrednosti odvoda $f'(x)$. Uporabimo
lahko numerične približke za odvod, vendar pri tem izgubimo natančnost. 

Osnovna ideja avtomatskega odvajanja je v tem, da odvajamo program. Računalniški program ni nič drugega kot zaporedje osnovnih
računskih operacij in premetavanja vrednosti po pomnilniku. V našem primeru
uporabljamo dve spremenljivki \texttt{x} in \texttt{y}, zato si lahko vsako vrstico
programa, ki spreminja vrednosti \texttt{x} ali \texttt{y} predstavljamo kot
funkcijo $\phi_i:\RR^2\to\RR^2$. Označimo z $(x_k,y_k)$ vrednosti spremenljivk
\texttt{x} in \texttt{y}, po izvedbi $k$-te vrstice programa in pred izvedbo
$k+1$-ve vrstice. Vsaka vrstica programa določa preslikavo
\begin{eqnarray*}
  \phi_k&:&\RR^2\to \RR^2\\
  \phi_k&:&(x_{k-1},y_{k-1})\mapsto (x_k,y_k).
\end{eqnarray*}
Celoten program predstavlja preslikavo $F:(x_0,y_0)\mapsto (x_n,y_n)$, ki jo
lahko predstavimo kot kompozitum preslikav $\phi_k$, defniranih z vsako vrstico programa:
\begin{equation*}
  F(x_0,y_0) = \phi_n\circ\phi_{n-1}\circ \ldots \phi_1(x_0,y_0) = \phi_n(\phi_{n-1}(\ldots \phi_1(x_0,y_0)\ldots))
\end{equation*}

Odvod preslikave $F$ lahko po verižnem pravilu izrazimo kot produkt Jacobijevih matrik
$D\phi_i$ preslikav $\phi_i$. Ker nas zanima le odvod $y$ po $x$, matriko $DF$
pomnožimo z leve in desne z vektorjem $(0,1)$ 
\begin{equation}
\label{eq:kompozitum}
  \frac{dy}{dx} =
  \begin{bmatrix}
    0& 1
  \end{bmatrix}
\cdot D\phi_n(x_{n-1},y_{n-1})\cdot D\phi_{n-1}(x_{n-2},y_{n-2})\ldots D\phi_1(x_0,y_0)\cdot
  \begin{bmatrix}
    0\\
    1
  \end{bmatrix} 
\end{equation}
Program za računanje odvoda lahko povsem sledi originalnemu programu, le da si
mora na vsakem koraku zapomniti vmesne vrednosti odvoda. Na vsakem
koraku programa, si mora program za odvod zapomniti vektor
\begin{equation*}
\begin{bmatrix}dx_{k}\\dy_{k}\end{bmatrix} = D\phi_{k}(x_{k-1},y_{k-1})\ldots D\phi_1(x_0,y_0)\cdot \begin{bmatrix} 0\\ 1\end{bmatrix} 
\end{equation*}
Vrednost $(dx_k,dy_k)$ lahko definiramo rekurzivno
\begin{equation}
  \label{eq:rek_odvod}
\begin{bmatrix}dx_{k}\\dy_{k}\end{bmatrix} = D\phi_{k}(x_{k-1},y_{k-1})\cdot \begin{bmatrix} dx_{k-1}\\ dy_{k-1}\end{bmatrix} 
\end{equation}
V našem primeru je 
\begin{equation*}
  \phi_1(x,y)=(x,x/2)\text{ in } \phi_n(x,y)=\left(x,\frac{1}{2}\left( y+\frac{x}{y} \right)\right)
\end{equation*}
Vrednost spremenljivke $x$ se ne spreminja tekom programa, zato je dovolj, da
spremljamo le vrednosti odvoda po $y$
\begin{equation*}
  \frac{d}{dx}\phi_0(x,y(x))_2=1/2\text{ in }\frac{d}{dx}\phi_k(x,y(x))_2=\frac{1}{2}\left( \frac{dy}{dx}+\left(\frac{1}{y}-\frac{x}{y^2}\frac{dy}{dx}\right) \right)
\end{equation*}
 
Naslednji program poleg vrednosti funkcije (spremenljivka \texttt{y}) računa
tudi njen odvod (spremenljivka \texttt{dy})
\begin{verbatim}
dy = 0.5
y = x/2
while abs(y*y-x) > eps:
  dy = (dy + (1/y - x/(y*y)*dy)/2
  y = (y+x/y)/2
\end{verbatim}

\section{Avtomatsko odvajanje}
Na uvodnem primeru smo videli, da si lahko računalniški program predstavljamo
kot vektorsko funkcijo več spremenljivk. Vektorska funkcija, ki predstavlja
program, je podana kot kompozitum preslikav, ki ustrezajo posameznim vrsticam
programa. Program za odvod smo napisali tako, da smo vsaki vrstici
programa dodali vrstico, ki je izračunala odvod. Ta postopek lahko namesto nas
opravi računalnik (od tod ime avtomatski odvod). V nadaljevanju bomo opisali dva
načina, kako je to izvedeno v obstoječih knjižnicah. 

Oglejmo si matematični model, s katerim lahko utemeljimo postopke avtomatičnega
odvajanja. Računalniški spomin si lahko predstavljamo Upoštevamo le vrednosti
tipa \texttt{float} (števila s plavajočo vejico), s katerimi v računalniku
predstavljamo realna števila. Ostale spremenljivke, kot so števci v zankah, logične
vrednosti in podobne ne bodo vključene v našem modelu, ampak jih upoštevamo
zgolj kot parametre, ki sicer vplivajo na potek programa, vendar njihovega
vpliva ne moremo infinitezimalno obravnavati. Če predpostavimo, da so vse
spremenjivke, ki nas zanimajo tipa \texttt{float}, si lahko stanje spomina
predstavljamo kot $n$-razsežni realni vektor\footnote[1]{omejitev, da je
  spremenljivka tipa \texttt{float}, smo vpeljali zgolj zaradi enostavnosti.
  Odvajamo lahko po poljubnem tipu, ki to dopušča. Če bi npr. definirali
  poseben tip, ki bi predstavljal funkcijo, bi na isti način lahko računali
  funkcijski odvod, kot ga poznamo v variacijskem računu.}. Vsaka spremenljivka(lokacija v
spominu) predstavlja eno komponento tega vektorja. Množico vseh možnih stanj
spomina, s katerim razpolaga program, lahko modeliramo z $n$-razsežnim
vektorskim prostorom $\RR^n$.  Računalniški program, ki
ima na voljo $n$-mest v spominu, si lahko predstavljamo kot preslikavo
\begin{equation}
  \label{eq:program_kot_preslikava}
  P: \RR^n\to\RR^n
\end{equation}
Množica vseh takih preslikav opremljena z operacijo kompozituma je monoid.
Preslikava $P:\RR^n\to \RR^n$ je odvedljiva v $x\in\RR^n$, če obstaja linearna
preslikava $TP_x:\RR^n\to\RR^n$, za katero je 
\begin{equation}
  \label{eq:frechet}
  \lim_{h\to 0}\frac{\|P(x+h)-P(x)-TP_x(h)\|}{\|h\|} = 0.
\end{equation}
Preslikavo $TP_x$ imenujemo \emph{Fréchetov odvod} ali \emph{linearizacija}
preslikave $P$. Za preslikave $\RR^n\to \RR^m$ lahko Fréchetov odvod
izrazimo kot množenje vektorja $h$ z Jacobijevo matriko parcialnih odvodov
komponent preslikave $P$
\begin{equation*}
  TP_x(h) = JP(x)\cdot h.
\end{equation*}
Preslikave, ki so določene z osnovnimi ukazi in operacijami v določenem
programskem jeziku, predstavljajo generatorje vseh možnih programomv v tem
monoidu. Označimo z $E$ množico vseh elementarnih ukazov in operacij, ki so
implementirane v programskem jeziku. Označimo z $\T$ prostor končnih programov,
ki so generirani z elementarnimi operacijami iz $\E$
\begin{equation*}
  \T=\langle E \rangle
\end{equation*}

Predpostavimo za trenutek, da so vse elementarne operacije povsod odvedljive. 

\begin{izrek}
  Preslikava $\tau:T\to T$, ki vsakemu programu priredi njegov odvod je
  homomorfizem monoida $(T,\circ)$. 
\end{izrek}
Ponavadi nas ne zanima odvod po vseh spremenljvkah, ki jih imamo v programu.
Označimo z $e_i,\quad i=1,2,\ldots n$ standardne bazne vektorje v $\RR^n$ in z
$\II\subset\{1,2,\ldots n\}$ množico indeksov. Indeksi v $\II$ ustrezajo
posameznim spremenljivkam (indeksi določajo lokacijo spremenljivke v spominu). Naj bo $V_\II$ vektorski
podprostor napet na vektorje $\{e_i;\quad i\in\II\}$. Označimo z 
$\mathcal{P}_\II$ projekcijo na $V_i$, z $\mathcal{I}_\II$ pa vložitev $V_\II$ v
$\RR^n$. Vložitev $\mathcal{I}_\II$ ni mišljena kot linearna preslikava, ampak
dopuščamo, da so vrednosti spremenljivk, ki niso v $\II$, poljubne. Recimo, da nas zanima nabor spremenljivk z indeksi $\II$, ki jih
program $P$ izračuna na podlagi nabora spremenljivk z indeksi $\mathbb{J}$.
Preslikavo med $V_\JJ\to V_\II$, ki jo določa program $P$, lahko zapišemo kot
\begin{equation}
  \label{eq:zozitev}
  P^{\JJ}_{\II}=\mathcal{P}_\II\circ P\circ \mathcal{I}_\JJ 
\end{equation}
Odvod preslikave $ P^{\JJ}_{\II}$ je enak produktu
\begin{equation*}
  P^{\JJ}_{\II}=P_\II\cdot DP\cdot I_\JJ,   
\end{equation*}
kjer sta $P_\II$ in  $I_\JJ$ matriki, ki ustrezata projekciji na $V_\II$ oziroma
vložitvi $V_\JJ$ v $\RR^n$.

\subsection{Kontrolne strukture}   
\subsection{Direktno odvajanje}
\subsection{Obratno odvajanje}
\end{document}
