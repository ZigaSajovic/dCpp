{
  "name": "dCpp",
  "tagline": "Infinitely- differentiable C++; conditionals, loops, recursion and all things C++",
  "body": "# dCpp\r\nInfinitely-differentiable C++; conditionals, loops, recursion and all things C++\r\n\r\n###Abstract\r\nWe provide an illustrative implementation of an analytic, infinitely-differentiable machine, implementing infinitely-differentiable programming spaces and operators acting upon them, as constructed in the paper _Operational calculus on programming spaces and generalized tensor networks_. Implementation closely follows theorems and derivations of the paper, intended as an educational guide.\r\n\r\nThis is the openSource version.\r\n\r\n###Theory\r\n\r\nFrom _abstract_ of the paper  _Operational calculus on programming spaces and generalized tensor networks_ in which the theory is derived by [Žiga Sajovic](https://www.linkedin.com/in/zigasajovic):\r\n\r\nIn this paper, we develop the theory of analytic virtual machines, that\r\nimplement analytic programming spaces and operators acting upon them. Such a machine fully integrates control structures, reataining the expressive freedom of algorithmic control flow.\r\n\r\nA programming space is a subspace of the function space of maps on the virtual\r\nmemory. We can construct a differential operator on programming spaces as we \r\nextend the virtual memory to a tensor product of a virtual space with tensor algebra\r\nof its dual. Extended virtual memory serves by itself as an algebra of programs, giving the expansion of the original program as an infinite tensor series at\r\nprogram's input values. \r\n\r\nA paper explaining implementation of this theory is avaliable [/paper/dCpp.pdf](https://zigasajovic.github.io/dCpp/paper/dCpp.pdf).\r\n\r\nThe paper _Operational calculus on programming spaces and generalized tensor networks_ , containing construction of the theory will soon be available on arXiv.\r\n\r\n\r\n###Usage\r\nBy employing analytic virtual machines, we can construct analytic procedures, viewing algorithms in a new light. One can start incorporating variable parameters into algorithm design, revealing the true nature of hyper-parameters often used in practice.\r\n\r\n###Tutorial\r\nAs most programmers face the need of differentiability through machine learning, we use the concept a [Recurrent neural network](https://en.wikipedia.org/wiki/Recurrent_neural_network) employing [logistic regression](https://en.wikipedia.org/wiki/Logistic_regression) with [softmax normalization](https://en.wikipedia.org/wiki/Softmax_function#Softmax_Normalization) as a vessel for this tutorial. We demostrate, how it is simply constructed using algorithmic control flow and reccursion, by employing _dCpp_.\r\n\r\nFirst we include the necessities\r\n\r\n```c++\r\n#include <iostream>\r\n#include <dCpp.h>\r\n#include <vector>\r\n```\r\n\r\nWe initialize a n-differentiable programming space (order is arbitrary here)\r\n\r\n```c++\r\nusing namespace dCpp;\r\nint n_differentiable=2;\r\ninitSpace(n_differentiable);\r\n```\r\n\r\nWe will need the folowing functions\r\n* [sigmoid(x)](https://en.wikipedia.org/wiki/Sigmoid_function)\r\n* [softmax(vec)](https://en.wikipedia.org/wiki/Softmax_function)\r\n* [dotProduct(vec1,vec2)](https://en.wikipedia.org/wiki/Dot_product)\r\n* [matVecProduct(mat,vec)](https://en.wikipedia.org/wiki/Matrix_multiplication)\r\n\r\n####Maps contained in the function algebra over var\r\n\r\nBy coding sigmoid(x), we will learn about creating differentiable maps, constructable using the differentiable programming space _dCpp_ and the algebra of the virtual memory _var_.\r\n```c++\r\nvar sigmoidMap(const var&v){return 1/(1+exp(-1*v));};\r\n\r\n```\r\nWe test it out and and compute it on a simple example.\r\n\r\n```c++\r\n//  set inputs\r\n    double x=4;\r\n    double y=2;\r\n//  set weights\r\n    var w_1(0.4);\r\n    var w_2(0.6);\r\n//  initialize weights as twice differentiable variables\r\n    dCpp::init(w_1);\r\n    dCpp::init(w_2);\r\n//  now we use sigmoid map as a differentiable map\r\n    var f=sigmoidMap(w_1*x+w_2*y);\r\n```    \r\nAccessing the derivatives is done by calling _d(var* w)_ function of the class _var_. It returns the derivative with respect to the variable _w_, as a _var_ variable.\r\n\r\n```c++\r\n//  df/dw_1\r\n    std::cout<<\"df/dw_1 = \"<<f.d(&w_1).id<<std::endl;\r\n//  df/dw_2\r\n    std::cout<<\"df/dw_2 = \"<<f.d(&w_2).id<<std::endl;\r\n//  df/dw_1dw_1\r\n    std::cout<<\"df/dw_1dw_1 = \"<<f.d(&w_1).d(&w_1).id<<std::endl;\r\n//  df/dw_1dw_2\r\n    std::cout<<\"df/dw_1dw_2 = \"<<f.d(&w_1).d(&w_2).id<<std::endl;\r\n//  df/dw_2dw_1\r\n    std::cout<<\"df/dw_2dw_1 = \"<<f.d(&w_2).d(&w_1).id<<std::endl;\r\n//  df/dw_2dw_2\r\n    std::cout<<\"df/dw_2dw_2 = \"<<f.d(&w_2).d(&w_2).id<<std::endl;\r\n```\r\n\r\n####Operator dTau\r\n\r\n Similarly, we could have used the operator [tau](include/tau.h) by coding , which allows one to create it's own elements of the differentiable programming space _dCpp_, returning a differentiable variable [var](/include/var.h). The operator [tau](include/tau.h) is initialized by a double-->double map representing the desired function, and a var-->var map representing its derivative. Lets take a closer look, by creating a differentiable map log:var-->var.\r\n \r\n ```c++\r\n //coding the derivative\r\n var log_primitive(const var&v){return 1/v;};\r\n```\r\nThe map is created by providing the operator with the two maps\r\n ```c++\r\n //operator returning a differentiable map\r\ntau log(std::log,log_primitive);\r\n```\r\nThe map is now ready to use\r\n ```c++\r\n //  set variables\r\n    var x(10);\r\n    var y(20);\r\n//  initialize x and y as a differentiable variables\r\n    dCpp::init(x);\r\n    dCpp::init(y);\r\n //  now we use log as a differentiable map\r\n    var f=log(((x^2)-(y^0.23))^2.1);\r\n```\r\nAgain, we display all first and second derivatives\r\n ```c++\r\n//  df/dx\r\n    std::cout<<\"df/dx = \"<<f.d(&x).id<<std::endl;\r\n//  df/dy\r\n    std::cout<<\"df/dy = \"<<f.d(&y).id<<std::endl;\r\n//  df/dxdx\r\n    std::cout<<\"df/dxdx = \"<<f.d(&x).d(&x).id<<std::endl;\r\n//  df/dxdy\r\n    std::cout<<\"df/dxdy = \"<<f.d(&x).d(&y).id<<std::endl;\r\n//  df/dydx\r\n    std::cout<<\"df/dydx = \"<<f.d(&y).d(&x).id<<std::endl;\r\n//  df/dydy\r\n    std::cout<<\"df/dydy = \"<<f.d(&y).d(&y).id<<std::endl;\r\n```\r\n####Integrating control structures\r\n\r\nWith _dTau_ explained, we turn to coding the softmax normalization, we reveal how analytic virtual machines fully integrate control structures. \r\n\r\n```c++\r\n//simply code the map existing in the programming space dCpp\r\n//and the belonging algebra\r\nstd::vector<var> softmax(const std::vector<var>& V){\r\n    std::vector<var> out;\r\n    var sum(0);\r\n    init(sum);\r\n    for(var v:V){\r\n        sum=sum+exp(v);\r\n    }\r\n    for(var v:V){\r\n        out.push_back(exp(v)/sum);\r\n    }\r\n    return out;\r\n}\r\n\r\n```\r\nWe test it, by inititalizing a four-differentiable programming space and displaying all derivatives.\r\n\r\n```c++\r\n//  initiaize Virtual memory of fourth order\r\n    initSpace(4);\r\n//get a vector of variables\r\n    int size=2;\r\n    std::vector<var> vars;\r\n    for(int i=1;i<=size;i++){\r\n        var tmp=var(i);\r\n        init(tmp);\r\n        vars.push_back(tmp);\r\n    }\r\n//  use the softmax function\r\n    std::vector<var> f=softmax(vars);\r\n//  display derivatives of all four orders\r\n//   of one of the components\r\n    f[1].print();\r\n\r\n```\r\n####Recurrent neural network\r\n\r\nAssume existence of functions _vecSum_, _matVecProd_, _genRandVec_ and _forAll_ written in a similar fashion. Thus, we have all the tools needed to build a recursive layer. It will consist of two layers, mapping a 2-vector to a 2-vector. Output of the second layer will be recursively connected to the input of the next recursive layer.\r\n\r\nFor brevity, we denote _std::vector<std::vector<var> >_ by _mat_ and _std::vector<var>_ by _vec_.\r\n\r\n```c++\r\nvec recursionNet(vec input, mat weights[2],vec bias[], int depth){\r\n    if(depth==0){\r\n        return softmax(input);\r\n    }\r\n    else{\r\n        vec firstOut;\r\n        //matrix vector multiplication\r\n        firstOut=matVecProd(weights[0],input);\r\n        firstOut=vecSum(firstOut,bias[0]);\r\n        forAll(firstOut,sigmoid);\r\n        vec secondOut;\r\n        secondOut=matVecProd(weights[1],firstOut);\r\n        secondOut=vecSum(secondOut,bias[1]);\r\n        forAll(secondOut,sigmoid);\r\n        return recursionNet(secondOut,weights, bias,depth-1);\r\n    }\r\n}\r\n```\r\n\r\nNow only some initialization of weights is needed and the network can be used, exactly like any other function would, with the exception, that this function is _n-differentiable_.\r\n\r\n```c++\r\nvec output = recursionNet(input,weights[],bias[], depth);\r\nfor(var v:output)v.print();\r\n```\r\n\r\nto display derivatives of all orders, up to _n_ by which the space has been initialized.\r\n\r\n###External libraries\r\n\r\nUsage with external libraries written in generic paradigm is demonstrated on the example of [Eigen](http://eigen.tuxfamily.org/). \r\nWe will code a perceptron with sigmoid activations, followed by softmax normalization. We will use dCpp provided mappings in the _dEigen_ header.\r\n\r\n```c++\r\n#include <iostream>\r\n#include <dCpp.h>\r\n#include <dEigen.h>\r\n\r\nusing namespace std;\r\nusing namespace dCpp;\r\n\r\n//create a softmax function\r\ntemplate <typename Derived>\r\nvoid softmax(Eigen::MatrixBase<Derived>& matrix){\r\n        //maps each element of the matrix by y=e^x;\r\n        dCpp::map_by_element(matrix,&dCpp::exp);\r\n        //sums the elements of the matrix using Eigens function\r\n        var tmp=matrix.sum();\r\n        //divides each element by the sum\r\n        for (size_t i=0, nRows=matrix.rows(), nCols=matrix.cols(); i<nCols; ++i)\r\n            for (size_t j=0; j<nRows; ++j)matrix(j,i)=matrix(j,i)/tmp;\r\n}\r\n\r\n\r\nvoid dEigenExample(){\r\n    //    space is n-times differentiable\r\n    int n=2;\r\n    //    initialize the space\r\n    dCpp::initSpace(n);\r\n    //    Matrix holding the inputs (imgSizeX1 vector)\r\n    const int inputSize=28;\r\n    Eigen::Matrix<var,1,inputSize>input=Eigen::Matrix<var,1,inputSize>::Random(1,inputSize);\r\n    dCpp::init(input);\r\n    //    number of outputs of the layer\r\n    const int outputSize=1;\r\n    //    matrix of weights on the first level (imgSizeXnumOfOutOnFirstLevel)\r\n    Eigen::Matrix<var,inputSize,outputSize>firstLayerVars=Eigen::Matrix<var,inputSize,outputSize>::Random(inputSize,outputSize);\r\n    //    initializing weights\r\n    dCpp::init(firstLayerVars);\r\n    //    mapping of the first layer\r\n    Eigen::Matrix<var,outputSize,1>firstLayerOutput=input*firstLayerVars;\r\n    //    add bias\r\n    Eigen::Matrix<var,outputSize,1>bias=Eigen::Matrix<var,outputSize,1>::Random(outputSize,1);\r\n    //    initialize bias\r\n    dCpp::init(bias);\r\n    firstLayerOutput=bias+firstLayerOutput;\r\n    //    apply sigmoid we coded earlier\r\n    dCpp::map_by_element(firstLayerOutput,sigmoid);\r\n    //    apply sofmax layer\r\n    softmax(firstLayerOutput);\r\n    //    display the first output layer and its (1-n)-th derivatives\r\n    for (size_t i=0, nRows=firstLayerOutput.rows(), nCols=firstLayerOutput.cols(); i<nCols; ++i){\r\n                for (size_t j=0; j<nRows; ++j) firstLayerOutput(j,i).print();\r\n                cout<<endl;\r\n    }\r\n}\r\n```\r\n\r\n<a rel=\"license\" href=\"http://creativecommons.org/licenses/by/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by/4.0/88x31.png\" /></a><br /><span xmlns:dct=\"http://purl.org/dc/terms/\" property=\"dct:title\">dC++</span> by <a xmlns:cc=\"http://creativecommons.org/ns#\" href=\"https://si.linkedin.com/in/zigasajovic\" property=\"cc:attributionName\" rel=\"cc:attributionURL\">Žiga Sajovic</a> is licensed under a <a rel=\"license\" href=\"http://creativecommons.org/licenses/by/4.0/\">Creative Commons Attribution 4.0 International License</a>.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}